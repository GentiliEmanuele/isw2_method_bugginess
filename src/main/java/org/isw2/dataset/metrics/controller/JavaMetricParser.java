package org.isw2.dataset.metrics.controller;

import com.sun.source.tree.CompilationUnitTree;
import com.sun.source.tree.Tree;
import com.sun.source.util.JavacTask;
import com.sun.source.util.Trees;
import org.isw2.dataset.core.model.Method;
import org.isw2.dataset.core.model.MethodKey;
import org.isw2.dataset.exceptions.ProcessingException;
import org.isw2.absfactory.Controller;
import org.isw2.dataset.metrics.MethodParserScanner;
import org.isw2.dataset.metrics.controller.context.ParserContext;

import javax.tools.*;
import java.io.IOException;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JavaMetricParser implements Controller<ParserContext, Map<MethodKey, Method>> {

    // Get access to JavaCompiler
    private final JavaCompiler compiler;
    /* We need an appropriate JavaFileManager instance and an appropriate collection JavaFileObject instances to do
    this. */
    private final StandardJavaFileManager fileManager;

    JavaMetricParser() {
        this.compiler = ToolProvider.getSystemJavaCompiler();
        this.fileManager = this.compiler.getStandardFileManager(null, null, StandardCharsets.UTF_8);
    }

    private static class SingletonHelper {
        private static final JavaMetricParser INSTANCE = new JavaMetricParser();
    }

    public static JavaMetricParser getInstance() {
        return SingletonHelper.INSTANCE;
    }

    @Override
    public Map<MethodKey, Method> execute(ParserContext context) throws ProcessingException {
        Map<MethodKey, Method> methods = new HashMap<>();

        if (isGeneratedFile(context.content())) {
            return methods;
        }

        // Create a virtual file in memory
        JavaFileObject fileObject = new SimpleJavaFileObject(URI.create("string:///" + context.filePath()), JavaFileObject.Kind.SOURCE) {
            @Override
            public CharSequence getCharContent(boolean ignoreEncodingErrors) {
                return context.content();
            }
        };

        JavacTask javacTask = (JavacTask) compiler.getTask(null, fileManager, null, null, null, List.of(fileObject));
        try {
            Iterable<? extends CompilationUnitTree> compilationUnitTrees = javacTask.parse();
            Trees trees = Trees.instance(javacTask);
            parseCompilationUnitTree(compilationUnitTrees, trees, methods, context.filePath());
        } catch (IOException e) {
            throw new ProcessingException(e.getMessage());
        }
        return methods;
    }

    private boolean isGeneratedFile(String content) {
        return content.contains("Generated by the protocol buffer compiler");
    }

    private void parseCompilationUnitTree(Iterable<? extends CompilationUnitTree> compilationUnitTrees, Trees trees, Map<MethodKey, Method> outMethods, String path) {
        for (CompilationUnitTree compilationUnitTree : compilationUnitTrees) {
            parseTrees(compilationUnitTree, trees, outMethods, path);
        }
    }

    private void parseTrees(CompilationUnitTree compilationUnitTree, Trees trees, Map<MethodKey, Method> methods, String path) {
        MethodParserScanner scanner = new MethodParserScanner(compilationUnitTree, trees, methods, path);
        for (Tree tree : compilationUnitTree.getTypeDecls()) {
            tree.accept(scanner, null);
        }
    }

}
